// Lost Grid v2.0.0 - https://github.com/corysimmons/lost

$gutter: 30px !default;
$rtl: false !default;


/// Sets a translucent background color to all elements it affects. Helpful while setting up, or debugging, the structure of your site to make sure all items are cleared correctly.
///
/// @param {color} $bg [blue] - A color to be lightened, so make sure you pick a darkish color.
///
/// @example
///   section {
///     @include edit(red);
///   }

@mixin edit($bg: blue) {
  * {
    background: rgba($bg, 0.1);
  }
}


/// Clearfix used to clear floated children boxes. http://nicolasgallagher.com/micro-clearfix-hack
///
/// @example
///   .parent {
///     @include cf;
///     .child {
///       @include box(1/2);
///     }
///   }

@mixin cf() {
  *zoom: 1;

  &:before, &:after {
    content: '';
    display: table;
  }

  &:after {
    clear: both;
  }
}


/// Vertically and/or horizontally align nested elements.
///
/// @param {string} $dir [both] - Direction. Either vertical, v, horizontal, or h. Defaults to both.
///
/// @example
///   .parent {
///     @include align(vertical);
///     width: 600px;
///     height: 400px;
///     .child {
///       width: 300px;
///       height: 150px;
///     }
///   }

@mixin align($dir: both) {
  display: flex;
  @if ($dir == 'horizontal') or ($dir == 'h') {
    justify-content: center;
  } @else if ($dir == 'vertical') or ($dir == 'v') {
    align-items: center;
  } @else if ($dir == 'reset') {
    justify-content: inherit;
    align-items: inherit;
  } @else {
    justify-content: center;
    align-items: center;
  }
}


/// Creates a horizontal or vertical container for blocks. Applies a negative margin on each side of the element depending on it's direction. This is required when adding blocks to negate their outer margins. The row version of this mixin automatically applies clearfix as it's assumed floated elements will be nested within it.
///
/// @param {string} $dir [row] - The direction of the nested grid system. Accepts row, column, or both.
/// @param {number} $gut [$gutter] - The gutter width. This is typically left alone, but if you want a specific box/block combination to have a larger or smaller gutter, you need to specify the same $gut on both types of elements.
///
/// @example
///   .parent {
///     @include box;
///     .children {
///       @include block(1/2);
///     }
///   }

@mixin box($dir: row, $gut: $gutter) {
  @if ($dir == row) {
    @include cf;
    margin-left: -($gut / 2);
    margin-right: -($gut / 2);
    overflow-x: hidden;
    overflow-y: inherit;
    height: auto;
    @if ($gut != 0) {
      width: calc(100% + #{$gut});
    } @else {
      width: 100%;
    }
  } @else if ($dir == column) {
    margin-top: -($gut / 2);
    margin-bottom: -($gut / 2);
    overflow-x: inherit;
    overflow-y: hidden;
    @if ($gut != 0) {
      height: calc(100% + #{$gut});
    } @else {
      height: 100%;
    }
  } @else {
    margin: -($gut / 2);
    overflow: hidden;
    @if ($gut != 0) {
      width: calc(100% + #{$gut});
      height: calc(100% + #{$gut});
    } @else {
      width: 100%;
      height: 100%;
    }
  }
}


/// Creates a box that is a fraction of the size of it's containing element with a margin on each side of the element. You don't need to pass any additional ratios (fractions), as the grid system will make use of calc().
///
/// @param {fraction} $fraction [1] - This is a simple fraction of the containing element's width or height depending on $dir.
/// @param {string} $dir [row] - The direction of the containing grid. Can be row (horizontal grid), column (vertical grid), or both.
/// @param {number} $gut [$gutter] - The margin on each side of the element used to create a gutter. Typically this is left alone, but if you need to have a specifically large or small gutter, you will need to alter this along with the containing row's gutter so they are the same.
/// @param {boolean} $output [normal] - Determines what type of code to output. Accepts normal (all styles for a box), init (the initial styles of any box), or bare (just the width of the box). Useful for creating CSS classes with Lost.
///
/// @example
///   .parent {
///     @include box;
///     .children {
///       @include block(1/4);
///     }
///   }

@mixin block($fraction: 1, $dir: row, $gut: $gutter, $output: normal) {
  @if ($dir == row) {
    @if ($output == init) or ($output == normal) {
      @if ($rtl) {
        float: right;
      } @else {
        float: left;
      }
    }
    @if ($gut > 0) {
      @if ($output == normal) or ($output == bare) {
        width: calc(100% * #{$fraction} - #{$gut});
      }
      @if ($output == normal) or ($output == init) {
        height: inherit;
        margin-left: ($gut / 2);
        margin-right: ($gut / 2);
      }
      @if ($gut == 0) {
        @if ($output == normal) or ($output == bare) {
          width: calc(100% * #{$fraction});
        }
      }
    }
  } @else if ($dir == column) {
    @if ($output == init) or ($output == normal) {
      width: 100%;
      @if ($rtl) {
        float: right;
      } @else {
        float: left;
      }
    }
    @if ($gut > 0) {
      @if ($output == normal) or ($output == bare) {
        height: calc(100% * #{$fraction} - #{$gut});
      }
      @if ($output == normal) or ($output == init) {
        margin-top: ($gut / 2);
        margin-bottom: ($gut / 2);
      }
    }
    @if ($gut == 0) {
      @if ($output == normal) or ($output == bare) {
        height: calc(100% * #{$fraction});
      }
    }
  } @else {
    @if ($output == init) or ($output == normal) {
      width: 100%;
      @if ($rtl) {
        float: right;
      } @else {
        float: left;
      }
    }
    @if ($gut > 0) {
      @if ($output == normal) or ($output == bare) {
        width: calc(100% * #{$fraction} - #{$gut});
        height: calc(100% * #{$fraction} - #{$gut});
      }
      @if ($output == normal) or ($output == init) {
        margin: ($gut / 2);
      }
    }
    @if ($gut == 0) {
      @if ($output == normal) or ($output == bare) {
        width: calc(100% * #{$fraction});
        height: calc(100% * #{$fraction});
      }
    }
  }
}


/// Margin to the left or right of an elements depending on if the fraction passed is positive or negative. Unfortunately it only works for horizontal grids as percentages are determined by container width exclusively.
///
/// @param {fraction} $fraction [false] - Fraction of the container to be offset.
/// @param {number} $gut [$gutter] - How large the gutter involved is, typically this won't be adjusted, but if you have set the boxes for that row to have different gutters than default, you will need to match that gutter here as well.
///
/// @example
///   .two-elements {
///     @include block(1/3);
///     &:first-child {
///       @include offset(1/3);
///     }
///   }

@mixin offset($fraction: false, $gut: $gutter) {
  @if ($gut > 0) {
    @if ($fraction > 0) {
      margin-left: calc(100% * #{$fraction} + (#{$gut} / 2));
    }
    @if ($fraction < 0) {
      margin-right: calc(-100% * #{$fraction} + (#{$gut} / 2));
    }
  }
  @if ($gut == 0) {
    @if ($fraction > 0) {
      margin-left: calc(100% * #{$fraction});
    }
    @if ($fraction < 0) {
      margin-right: calc(-100% * #{$fraction});
    }
  }
}


/// Source ordering. Useful for having an element appear above or below another element on mobile devices, and then to the opposite side on larger devices. For instance, a sidebar and article. You might want the sidebar to appear before the article on mobile, but be to the right of the article on desktop. This is how that is achieved. Unfortunately it only works for horizontal grids as percentages are determined by container width exclusively.
///
/// @param {fraction} $fraction [false] - Fraction of the container to be moved by it's left value.
/// @param {string} $output [normal] - Determines what styles are compiled. Accepts normal (all styles), init (only initialization styles), or bare (just the left position).
///
/// @example
///   .sidebar {
///     @media (min-width: 800px) {
///       @include block(1/3);
///       @include move(2/3);
///     }
///    }
///   .article {
///     @media (min-width: 800px) {
///       @include block(2/3);
///       @include move(-1/3);
///     }
///   }

@mixin move($fraction: false, $output: normal) {
  @if ($output == normal) or ($output == init) {
    position: relative;
  }
  @if ($output == normal) or ($output == bare) {
    left: calc(100% * #{$fraction});
  }
}


/// Since boxes are floated, when they are of unequal height, they will misalign easily. By setting cycle() you can make sure elements are being cleared on appropriate rows.
///
/// @param {number} $item [-1] - The nth-child + 1 element to clear on. If you want a row to be 3 elements wide, then you'd pass 3.
///
/// @example
///   .gallery {
///     img {
///       @include block(1/3);
///       @include cycle(3);
///     }
///   }

@mixin cycle($item: -1) {
  &:nth-child(n) {
    clear: none;
  }
  &:nth-child(#{$item}n + 1) {
    clear: both;
  }
}


/// Helper function for returning the width or height of an element.
///
/// @param {fraction} $fraction [false] - Fraction of the container.
/// @param {number} $gut [$gutter] - Gutter unit to be used in the calculation.
///
/// @example
///   .element {
///     width: size(1/2);
///     height: size(1/3);
///   }

@function size($fraction: false, $gut: $gutter) {
  @if ($gut != 0) {
    @return calc(100% * #{$fraction} - #{$gut});
  } @else {
    @return calc(100% * #{$fraction});
  }
}


/// Helper mixin for setting the gutters of an element.
///
/// @param {string} [$dir=row] - Whether this is a horizontal (row) or vertical (column) grid.
/// @param {number} [$gut=$gutter] - Gutter unit to be used in the calculation.
///
/// @example
///   .element {
///     @include gutters;
///   }

@mixin gutters($dir: row, $gut: $gutter) {
  @if ($dir == row) {
    @if ($gut != 0) {
      margin-left: ($gut / 2);
      margin-right: ($gut / 2);
    }
  } @else if ($dir == column) {
    @if ($gut != 0) {
      margin-top: ($gut / 2);
      margin-bottom: ($gut / 2);
    }
  } @else {
    @if ($gut != 0) {
      margin: ($gut / 2);
    }
  }
}


html, body {
  height: 100%;
}
